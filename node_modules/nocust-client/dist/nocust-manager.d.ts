import { WalletState } from './models/state/wallet-state.model';
import { NOCUSTClient } from './nocust-client';
import BigNumber from 'bignumber.js';
import { TransferDataInterface, OrderBookDataInterface } from './interfaces/data.interface';
import { Subscription } from 'rxjs';
import { NOCUSTManagerConfig, NOCUSTTransfer, NOCUSTManagerInterface } from './interfaces/nocust-manager.interface';
import BN from 'bn.js';
export declare class NOCUSTManager implements NOCUSTManagerInterface {
    nocustClient: NOCUSTClient;
    receiptSubscriptions: Map<string, Subscription>;
    contractAddress: string;
    operatorApiUrl: string;
    constructor(config: NOCUSTManagerConfig);
    isAddressRegistered(address: string, tokenAddress?: string): Promise<boolean>;
    registerAddress(address: string, tokenAddress?: string): Promise<void>;
    subscribeToIncomingTransfer(address: string, callback: (transaction: TransferDataInterface) => void, tokenAddress?: string): Promise<() => void>;
    sendTransaction(transfer: NOCUSTTransfer): Promise<number>;
    syncWallet(address: string, tokenAddress?: string): Promise<void>;
    deposit(address: string, amount: BigNumber | BN | string, gasPrice: BigNumber | BN | string, gas: number, tokenAddress?: string): Promise<string>;
    approveAndDeposit(address: string, amount: BigNumber | BN | string, gasPrice: BigNumber | BN | string, gas: number, tokenAddress?: string): Promise<string>;
    withdrawalRequest(address: string, amount: BigNumber | BN | string, gasPrice: BigNumber | BN | string, gas: number, tokenAddress?: string): Promise<string>;
    withdrawalConfirmation(address: string, gasPrice: BigNumber | BN | string, gas: number, tokenAddress?: string): Promise<string>;
    getNOCUSTBalance(address: string, tokenAddress?: string): Promise<BigNumber>;
    getSupportedTokens(): Promise<{
        tokenAddress: string;
        name: string;
        shortName: string;
    }[]>;
    getTransaction(transactionId: number): Promise<TransferDataInterface>;
    getTransactionsForAddress(address: string, tokenAddress?: string, eonNumber?: number): Promise<TransferDataInterface[]>;
    getWithdrawalLimit(address: string, tokenAddress?: string): Promise<BigNumber>;
    getOnChainBalance(address: string, tokenAddress?: string): Promise<BigNumber>;
    getBlocksToWithdrawalConfirmation(address: string, txHash?: string, tokenAddress?: string): Promise<number>;
    getWithdrawalFee(withdrawalRequestGasPrice: BigNumber | BN | string): Promise<BigNumber>;
    getEonNumber(): Promise<number>;
    getEraNumber(): Promise<number>;
    getBlockPerEon(): Promise<number>;
    getWalletState(address: string, tokenAddress?: string): Promise<WalletState>;
    getOrderBook(buyTokenAddress: string, sellTokenAddress: string): Promise<OrderBookDataInterface>;
    getSLADetail(): Promise<import("./interfaces/data.interface").SLADetailsInterface>;
    getSLAStatus(address: string): Promise<number>;
    buySLA(address: string): Promise<void>;
    isRecovery(): Promise<boolean>;
    isAddressRegisteredWithOperator(address: string, tokenAddress?: string): Promise<boolean>;
    sendSwap(address: string, buyTokenAddress: string, sellTokenAddress: string, buyAmount: BigNumber | BN | string, sellAmount: BigNumber | BN | string, subWalletSeedPhrase?: string): Promise<number>;
    synchronizeSwapOrders(address: string, buyTokenAddress: string, sellTokenAddress: string, forceAdmission?: boolean, subWalletSeedPhrase?: string): Promise<TransferDataInterface[]>;
    issueStateUpdateChallenge(address: string, gasPrice: any, gas: any, tokenAddress?: string): Promise<string>;
    issueDeliveryChallenge(address: string, txId: number, gasPrice: any, gas: any, tokenAddress?: string): Promise<string>;
    recoverFunds(address: string, gasPrice: any, gas: any, tokenAddress?: string): Promise<string>;
    private createWallet;
    private getSyncedWalletState;
    private registerAddressInternal;
}
