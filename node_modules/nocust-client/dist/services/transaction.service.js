"use strict";var __decorate=this&&this.__decorate||function(e,t,r,n){var a,i=arguments.length,s=i<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,n);else for(var o=e.length-1;0<=o;o--)(a=e[o])&&(s=(i<3?a(s):3<i?a(t,r,s):a(t,r))||s);return 3<i&&s&&Object.defineProperty(t,r,s),s},__metadata=this&&this.__metadata||function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)},__param=this&&this.__param||function(r,n){return function(e,t){n(e,t,r)}},__importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});var inversify_1=require("inversify"),bignumber_js_1=__importDefault(require("bignumber.js")),wallet_model_1=require("../models/wallet/wallet.model"),active_state_model_1=require("../models/transactions/active-state.model"),minimum_balance_marker_model_1=require("../models/transactions/minimum-balance-marker.model"),eon_model_1=require("../models/wallet/eon.model"),logging_1=require("../services/logging"),util_1=require("../util"),transfer_active_state_update_type_model_1=require("../models/transactions/transfer-active-state-update-type.model"),signature_model_1=require("../models/primitives/signature.model"),operator_api_service_1=require("../services/operator-api.service"),contract_api_service_1=require("../services/contract-api.service"),nocust_manager_error_model_1=require("../models/state/nocust-manager-error.model"),TransactionService=function(){function e(e,t){this.operatorApiService=e,this.contractApiService=t}return e.prototype.prepareSwap=function(c,u,l,_,p){var f=eon_model_1.Eon.fromJSON(c.latestEon.json),g=eon_model_1.Eon.fromJSON(u.latestEon.json);return new Promise(function(e,t){if(l.gt(c.offChainBalance))return t("Insufficient balance.");if(f.activeState.isTransferPending)return t("Another transfer is pending for the sender wallet.");if(g.activeState.isTransferPending)return t("Another transfer is pending for the recipient wallet.");if(!util_1.isSameHexValue(c.contractAddress,u.contractAddress))return t("Wallets are not in the same commit chain contract.");if(c.networkId!=u.networkId)return t("Wallets are not on the same network.");if(!util_1.isSameHexValue(c.address,u.address))return t("Sender and recipient wallet are not the same address.");if(util_1.isSameHexValue(c.tokenAddress,u.tokenAddress))return t("Cannot swap the same token for itself.");if(!c.isRegistered)return t("Unregistered sender wallet.");if(!u.isRegistered)return t("Unregistered recipient wallet.");if(f.eonNumber!=g.eonNumber)return t("Swapping wallets are in different rounds.");var r=f.activeState.createOutgoingSwap(u.address,u.tokenAddress,u.trailIdentifier,l,_,c.getEonSwapStartingBalance(c.latestEon.eonNumber),p);if(null===r)return t("No outgoing swap created.");var n=new minimum_balance_marker_model_1.MinimumAvailableBalanceMarker(c.contractAddress,c.tokenAddress,c.address,c.latestEon.eonNumber,c.offChainBalance.minus(l));if(null===n)return t("Balance marker not created");if(null===g.activeState.createIncomingSwap(c.address,c.tokenAddress,l,_,u.getEonSwapStartingBalance(u.latestEon.eonNumber),r.nonce))return t("No incoming swap created.");for(var a=eon_model_1.Eon.fromJSON(g.json),i=a.activeState.pendingTransfer,s=0,o=[transfer_active_state_update_type_model_1.TransferActiveStateUpdateType.DEBIT,transfer_active_state_update_type_model_1.TransferActiveStateUpdateType.CREDIT,transfer_active_state_update_type_model_1.TransferActiveStateUpdateType.FULFILLMENT];s<o.length;s++){var d=o[s];i.authorizations.set(d,{}),i.confirmations.set(d,signature_model_1.Signature.EMPTY)}return i.amountsMatched={out:l.toFixed(0),in:_.toFixed(0)},a.activeState.fulfillPendingSwap()?(logging_1.Logging.debug("Data prepared."),logging_1.Logging.debug({senderActiveState:[f.activeState.spent.toFixed(0),f.activeState.gained.toFixed(0),f.activeState.transferTree.hash,f.activeState.hash],recipientActiveState:[g.activeState.spent.toFixed(0),g.activeState.gained.toFixed(0),g.activeState.transferTree.hash,g.activeState.hash],recipientFulfillmentActiveState:[a.activeState.spent.toFixed(0),a.activeState.gained.toFixed(0),a.activeState.transferTree.hash,a.activeState.hash],marker:[n.amount.toFixed(0),n.hash]}),e({senderTransfer:r,recipientTransfer:r,hashes:{senderActiveState:f.activeState.hash,recipientActiveState:g.activeState.hash,recipientFulfillmentActiveState:a.activeState.hash,marker:n.hash},balanceMarker:c.offChainBalance.minus(r.amount)})):t("Fake swap fulfillment failure.")})},e.prototype.sendSwap=function(o,d,c,e,t,r,n){var a=this;return new Promise(function(i,s){a.operatorApiService.sendSwap(o,d,c,e,t,r,n).then(function(e){var t=o.getEon(c.senderTransfer.eonNumber),r=d.getEon(c.senderTransfer.eonNumber);if(!t||!r)return s("Could not send swap");var n=t.activeState.createOutgoingSwap(d.address,d.tokenAddress,d.trailIdentifier,c.senderTransfer.amount,c.senderTransfer.amountSwapped,c.senderTransfer.startingBalance,c.senderTransfer.nonce,e.id),a=r.activeState.createIncomingSwap(o.address,o.tokenAddress,c.recipientTransfer.amount,c.recipientTransfer.amountSwapped,c.recipientTransfer.startingBalance,c.recipientTransfer.nonce,e.id);return n&&a?i(e.id):s("Could not send swap")}).catch(s)})},e.prototype.sendSwapFreeze=function(r,n,a){var i=this;return new Promise(function(t,e){i.operatorApiService.sendSwapFreeze(r,n,a).then(function(e){return t(!0)}).catch(e)})},e.prototype.prepareSwapFinalization=function(e,t){var r=t.authorizations.get(transfer_active_state_update_type_model_1.TransferActiveStateUpdateType.FULFILLMENT);if(!r)return null;var n=new bignumber_js_1.default(t.amountsMatched.in);if(n.lt(t.amountSwapped))return null;var a=n.minus(t.amountSwapped);return{hashes:{recipientFinalizationActiveState:active_state_model_1.ActiveState.checksum(e.contractAddress,t.recipientTokenAddress,t.recipient,t.recipientTrailIdentifier,t.eonNumber,r.tx_set_hash,new bignumber_js_1.default(r.updated_spendings),new bignumber_js_1.default(r.updated_gains).plus(a))}}},e.prototype.sendSwapFinalization=function(r,n,a){var i=this;return new Promise(function(t,e){i.operatorApiService.sendSwapFinalization(r,n,a).then(function(e){return t(!0)}).catch(e)})},e.prototype.prepareSwapCancellation=function(e,t){var r=t.authorizations.get(transfer_active_state_update_type_model_1.TransferActiveStateUpdateType.DEBIT),n=t.authorizations.get(transfer_active_state_update_type_model_1.TransferActiveStateUpdateType.FULFILLMENT);if(!r)return logging_1.Logging.error("Missing debit authorization."),null;if(!n)return logging_1.Logging.error("Missing fulfillment authorization."),null;var a=new bignumber_js_1.default(t.amountsMatched.in),i=new bignumber_js_1.default(t.amountsMatched.out),s=t.amount.minus(i),o=a.multipliedBy(t.amount).dividedToIntegerBy(100),d=t.amountSwapped.multipliedBy(i).dividedToIntegerBy(100);if(o.lt(d))return logging_1.Logging.error("Unfair termination price."),null;var c=util_1.isSameHexValue(e.tokenAddress,t.tokenAddress);logging_1.Logging.debug([e.contractAddress,t.tokenAddress,t.sender,c?e.trailIdentifier:t.recipientTrailIdentifier,t.eonNumber,r.tx_set_hash,new bignumber_js_1.default(r.updated_spendings).toFixed(0),new bignumber_js_1.default(r.updated_gains).plus(s).toFixed(0),s.toFixed(0)]);var u=active_state_model_1.ActiveState.checksum(e.contractAddress,t.tokenAddress,t.sender,c?e.trailIdentifier:t.recipientTrailIdentifier,t.eonNumber,r.tx_set_hash,new bignumber_js_1.default(r.updated_spendings),new bignumber_js_1.default(r.updated_gains).plus(s));logging_1.Logging.debug([e.contractAddress,t.recipientTokenAddress,t.recipient,t.recipientTrailIdentifier,t.eonNumber,n.tx_set_hash,new bignumber_js_1.default(n.updated_spendings).plus(t.amountSwapped).toFixed(0),new bignumber_js_1.default(n.updated_gains).plus(a).toFixed(0),a.toFixed(0)]);var l=active_state_model_1.ActiveState.checksum(e.contractAddress,t.recipientTokenAddress,t.recipient,t.recipientTrailIdentifier,t.eonNumber,n.tx_set_hash,new bignumber_js_1.default(n.updated_spendings).plus(t.amountSwapped),new bignumber_js_1.default(n.updated_gains).plus(a));return logging_1.Logging.debug("Data prepared."),logging_1.Logging.debug({hashes:{senderCancellationActiveState:[new bignumber_js_1.default(r.updated_spendings).toFixed(0),new bignumber_js_1.default(r.updated_gains).plus(s).toFixed(0),r.tx_set_hash,u],recipientCancellationActiveState:[new bignumber_js_1.default(n.updated_spendings).plus(t.amountSwapped).toFixed(0),new bignumber_js_1.default(n.updated_gains).plus(a).toFixed(0),n.tx_set_hash,l]}}),{hashes:{senderCancellationActiveState:u,recipientCancellationActiveState:l}}},e.prototype.sendSwapCancellation=function(r,n,a,i){var s=this;return new Promise(function(t,e){s.operatorApiService.sendSwapCancellation(r,n,a,i).then(function(e){return t(!0)}).catch(e)})},e.prototype.prepareOutgoingTransfer=function(o,d,c,u,l){var _=this,p=eon_model_1.Eon.fromJSON(o.latestEon.json);return new Promise(function(i,s){return c.gt(o.offChainBalance)?s(new nocust_manager_error_model_1.NOCUSTManagerError("Insufficient commit-chain balance, current balance "+o.offChainBalance.toFixed(0)+" for token "+o.tokenAddress+". Send amount: "+c.toFixed(0),nocust_manager_error_model_1.NOCUSTError.INSUFFICIENT_COMMIT_CHAIN_BALANCE)):p.activeState.isTransferPending?s(new nocust_manager_error_model_1.NOCUSTManagerError("A pending transaction/swap id: "+p.activeState.pendingTransfer.txId+" is blocking the account",nocust_manager_error_model_1.NOCUSTError.SWAP_PENDING)):void _.operatorApiService.whoisWallet(o.tokenAddress,d,o.webAddress).then(function(n){if(!n||null==n.trail_identifier||null==n.trail_identifier)return s(new nocust_manager_error_model_1.NOCUSTManagerError("The recipient "+d+" is not registered with the NOCUST operator for token "+(util_1.isSameHexValue(o.tokenAddress,o.contractAddress)?"Ether":o.tokenAddress)+", therefore he can't receive any transactions. The recipient needs to register with the operator first using registerAddress at least once.",nocust_manager_error_model_1.NOCUSTError.UNREGISTERED_WITH_COMMIT_CHAIN));var a=new wallet_model_1.Wallet(d,o.networkId,o.contractOwnerAddress,o.contractAddress,o.tokenAddress,o.webAddress),e=a.getAdmissionActiveState(n.eon_number),t=signature_model_1.Signature.fromRSV(d,e.hash,n.wallet_signature);_.contractApiService.validateActiveStateSignature(e,t,o.contractAddress).then(function(e){if(!e)return s("Bad Recipient Admission Request.");var t=a.getAdmissionActiveState(n.eon_number,n.trail_identifier),r=signature_model_1.Signature.fromRSV(o.contractOwnerAddress,t.hash,n.operator_signature);_.contractApiService.validateActiveStateSignature(t,r,o.contractAddress).then(function(e){if(!e)return s("Bad Recipient Admission Approval.");var t=p.activeState.createOutgoingTransfer(d,n.trail_identifier,c,u,l);if(null===t)return s("No outgoing transfer created.");var r=new minimum_balance_marker_model_1.MinimumAvailableBalanceMarker(o.contractAddress,o.tokenAddress,o.address,o.latestEon.eonNumber,o.offChainBalance.minus(c));return null===r?s("No balance marker created."):(logging_1.Logging.debug("Data prepared."),logging_1.Logging.debug({transfer:t,hashes:{activeState:[p.activeState.spent.toFixed(0),p.activeState.gained.toFixed(0),p.activeState.transferTree.hash,p.activeState.hash],marker:[r.amount.toFixed(0),r.hash]}}),i({transfer:t,hashes:{activeState:p.activeState.hash,marker:r.hash},markerBalance:o.offChainBalance.minus(t.amount)}))})})}).catch(s)})},e.prototype.sendOutgoingTransfer=function(a,i,t,r){var s=this;return new Promise(function(n,e){s.operatorApiService.sendTransfer(a,i,t,r).then(function(e){var t=a.getEon(i.transfer.eonNumber);if(!t)return n(void 0);var r=t.activeState.createOutgoingTransfer(i.transfer.recipient,i.transfer.recipientTrailIdentifier,new bignumber_js_1.default(i.transfer.amount),i.transfer.isPassive,new bignumber_js_1.default(i.transfer.nonce),e.id,new bignumber_js_1.default(e.position));return n(r?e.id:void 0)}).catch(e)})},e.prototype.prepareReceipt=function(e,t){var r=eon_model_1.Eon.fromJSON(e.latestEon.json),n=r.activeState.createIncomingTransfer(t.sender,t.amount,t.nonce,t.txId,t.isPassive);return n?(logging_1.Logging.debug("Data prepared"),logging_1.Logging.debug({transfer:n,hashes:{activeState:[r.activeState.spent.toFixed(0),r.activeState.gained.toFixed(0),r.activeState.transferTree.hash,r.activeState.hash],marker:null}}),{transfer:n,hashes:{activeState:r.activeState.hash,marker:null},markerBalance:null}):null},e.prototype.sendIncomingTransferReceipt=function(a,i,t){var r=this;return new Promise(function(n,e){r.operatorApiService.sendReceipt(a,i.transfer.txId,t).then(function(e){var t=a.getEon(i.transfer.eonNumber);if(!t)return n(!1);var r=t.activeState.createIncomingTransfer(i.transfer.sender,i.transfer.amount,i.transfer.nonce,i.transfer.txId,i.transfer.isPassive);return n(!!r)}).catch(e)})},e=__decorate([inversify_1.injectable(),__param(0,inversify_1.inject(operator_api_service_1.OperatorApiService)),__param(1,inversify_1.inject(contract_api_service_1.ContractApiService)),__metadata("design:paramtypes",[operator_api_service_1.OperatorApiService,contract_api_service_1.ContractApiService])],e)}();exports.TransactionService=TransactionService;