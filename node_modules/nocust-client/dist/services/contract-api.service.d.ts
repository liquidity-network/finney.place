import 'reflect-metadata';
import { ProofOfExclusiveAllotment } from '../models/primitives/proof-of-exclusive-allotment.model';
import { Web3ServiceInterface } from '../interfaces/web3-service.interface';
import { Eon } from '../models/wallet/eon.model';
import { Signature } from '../models/primitives/signature.model';
import BigNumber from 'bignumber.js';
import { ActiveState } from '../models/transactions/active-state.model';
import { ActiveStateDataInterface, TransferDataInterface, TransferWalletDataInterface, ContractStateVariablesInterface } from '../interfaces/data.interface';
import { Transfer } from '../models/transactions/transfer.model';
export declare class ContractApiService {
    private web3Service;
    private contracts;
    constructor(web3Service: Web3ServiceInterface);
    getABI(contractAddress: string, abi?: import("web3/eth/abi").ABIDefinition[]): any;
    genesis(contractAddress: string): Promise<number>;
    getLiveChallenges(eonNumber: number, contractAddress: string): Promise<number>;
    currentEonNumber(contractAddress: string): Promise<number>;
    static eonNumberAt(latestBlockNumber: number, genesisBlockNumber: number, blocksPerEon: number): number;
    nextBlockEon(contractAddress: string): Promise<number>;
    currentSubBlock(contractAddress: string): Promise<number>;
    static subBlockAt(latestBlockNumber: number, genesisBlockNumber: number, blocksPerEon: number): number;
    nextBlockSubBlock(contractAddress: string): Promise<number>;
    lastSubmissionEon(contractAddress: string): Promise<number>;
    balance(walletAddress: string, tokenAddress?: string): Promise<BigNumber>;
    allowance(tokenAddress: string, walletAddress: string, contractAddress: string): Promise<BigNumber>;
    pendingWithdrawals(tokenAddress: string, eonNumber: any, eonsKept: any, contractAddress: string): Promise<BigNumber>;
    getBlocksPerEon(contractAddress: string): Promise<any>;
    getSlackPeriod(contractAddress: string): Promise<any>;
    getExtendedSlackPeriod(contractAddress: string): Promise<any>;
    getEonsKept(contractAddress: string): Promise<any>;
    getDepositsKept(contractAddress: string): Promise<any>;
    getChallengeCost(contractAddress: string): Promise<any>;
    recordBook(tokenAddress: string, walletAddress: string, contractAddress: string): Promise<boolean>;
    checkpoint(eonNumber: number, contractAddress: string, eonsKept: number): Promise<any>;
    clientContractStateVariables(tokenAddress: string, walletAddress: string, contractAddress: string): Promise<ContractStateVariablesInterface>;
    metamaskHashFix(rawHash: any): any;
    vrs(sig: any): string;
    signPersonal(data: any, account: any): Promise<Signature>;
    signInternalWithPrivateKey(data: any, account: any, privateKey: any): Promise<Signature>;
    signRaw(data: any, account: any, privateKey?: any): Promise<Signature>;
    sign(account: any, data: any): Promise<Signature>;
    recoverSigningAddress(signature: Signature, contractAddress: string, isLightSync?: boolean): Promise<string>;
    validateActiveStateSignature(activeState: ActiveState, signature: Signature, contractAddress: string): Promise<boolean>;
    validateDataActiveState(transferData: TransferDataInterface, activeStateData: ActiveStateDataInterface, activeStateWalletData: TransferWalletDataInterface, attestingAddress: string, contractAddress: string, tokenAddress: string, isLightSync: boolean, startingBalance?: BigNumber): Promise<boolean>;
    validateTransferDebit(transferData: TransferDataInterface, attestingAddress: string, contractAddress: string, tokenAddress: string, isLightSync: boolean): Promise<boolean>;
    validateTransferCredit(transferData: TransferDataInterface, attestingAddress: string, contractAddress: string, tokenAddress: string, isLightSync: boolean): Promise<boolean>;
    validateDeliveryProof(transfer: Transfer, deliveryProof: TransferDataInterface, contractAddress: string, tokenAddress: string, isLightSync: boolean): Promise<boolean>;
    validateSignature(signature: Signature, contractAddress: string): Promise<boolean>;
    getOperatorAccountAddress(contractAddress: string): Promise<string>;
    validateOperatorSignature(signature: Signature, contractAddress: string): Promise<boolean>;
    doNothingOnce(account: string, contractAddress: string, gasPrice: BigNumber, gas: number): Promise<any>;
    doNothing(count: number, account: string, contractAddress: string, gasPrice: BigNumber, gas: number): Promise<any>;
    getDeposits(walletAddress: string, eonNumber: number, depositsKept: number, tokenAddress: string, contractAddress: string): Promise<BigNumber>;
    getTotalDepositAtSlot(slot: number, tokenAddress: string, contractAddress: string): Promise<BigNumber>;
    getTotalDepositEonAtSlot(slot: number, tokenAddress: string, contractAddress: string): Promise<any>;
    getPendingWithdrawalsAtSlot(slot: number, tokenAddress: string, contractAddress: string): Promise<BigNumber>;
    getPendingWithdrawalsEonAtSlot(slot: number, tokenAddress: string, contractAddress: string): Promise<any>;
    getConfirmedWithdrawalsAtSlot(slot: number, tokenAddress: string, contractAddress: string): Promise<BigNumber>;
    getConfirmedWithdrawalsEonAtSlot(slot: number, tokenAddress: string, contractAddress: string): Promise<any>;
    deposit(tokenAddress: string, amount: BigNumber, account: string, contractAddress: string, gasPrice: BigNumber, gas: number, nonce?: number): Promise<any>;
    enableERC20Deposits(tokenAddress: string, walletAddress: string, contractAddress: string, gasPrice: BigNumber, gas: number, nonce?: number): Promise<any>;
    requestWithdrawal(amount: BigNumber, account: string, proof: ProofOfExclusiveAllotment, contractAddress: string, minGasCost: BigNumber, gasPrice: BigNumber, gas: number): Promise<any>;
    confirmWithdrawal(tokenAddress: string, account: string, contractAddress: string, gasPrice: BigNumber, gas: number): Promise<any>;
    hasOutstandingChallenges(contractAddress: string): Promise<boolean>;
    hasMissedCheckpointSubmission(contractAddress: string): Promise<boolean>;
    isPunished(contractAddress: string): Promise<boolean>;
    estimateChallengeInitialEmptyStateCost(tokenAddress: string, walletAddress: string, trailIdentifier: number, txSetRoot: string, spent: BigNumber, gained: BigNumber, operatorSignature: Signature, contractAddress: string): Promise<number>;
    submitChallengeInitialEmptyState(tokenAddress: string, walletAddress: string, trailIdentifier: number, txSetRoot: string, spent: BigNumber, gained: BigNumber, operatorSignature: Signature, responseReimbursement: BigNumber, contractAddress: string, gasPrice: BigNumber, gas: number): Promise<any>;
    estimateChallengeInitialMerkleStateCost(walletAddress: string, proof: ProofOfExclusiveAllotment, txSetRoot: string, spent: BigNumber, gained: BigNumber, operatorSignature: Signature, contractAddress: string): Promise<number>;
    submitChallengeInitialMerkleState(walletAddress: string, proof: ProofOfExclusiveAllotment, txSetRoot: string, spent: BigNumber, gained: BigNumber, operatorSignature: Signature, responseReimbursement: BigNumber, contractAddress: string, gasPrice: BigNumber, gas: number): Promise<any>;
    estimateDeliveryCommitmentCost(tokenAddress: string, walletAddress: string, senderAddress: string, recipientAddress: string, nonce: BigNumber, senderTrailIdentifier: number, transferMembershipTrail: number, recipientTrailIdentifier: number, chain: string[], txSetRoot: string, spent: BigNumber, gained: BigNumber, amount: BigNumber, operatorSignature: Signature, contractAddress: string): Promise<any>;
    submitDeliveryCommitment(tokenAddress: string, walletAddress: string, senderAddress: string, recipientAddress: string, nonce: BigNumber, senderTrailIdentifier: number, transferMembershipTrail: number, recipientTrailIdentifier: number, chain: string[], txSetRoot: string, spent: BigNumber, gained: BigNumber, amount: BigNumber, operatorSignature: Signature, responseReimbursement: BigNumber, contractAddress: string, gasPrice: BigNumber, gas: number): Promise<any>;
    getChallengeBook(tokenAddress: string, walletAddress: string, targetAddress: string, contractAddress: string): Promise<any>;
    verifyProofOfTransferAggregationRaw(transferMembershipTrail: number, chain: string[], target: string, amount: BigNumber, recipientTrailIdentifier: number, nonce: BigNumber, root: string, contractAddress: string, isPassive: boolean, passiveOffset: BigNumber, isLightSync: boolean): Promise<boolean>;
    verifyProofOfSwapAggregationRaw(sourceToken: string, destinationToken: string, transferMembershipTrail: number, chain: string[], amount: BigNumber, amountSwapped: BigNumber, startingBalance: BigNumber, recipientTrailIdentifier: number, nonce: BigNumber, root: string, contractAddress: string, isLightSync: boolean): Promise<boolean>;
    verifyProofOfTransitionAgreement(tokenAddress: string, walletAddress: string, trailIdentifier: number, eonNumber: number, txRoot: string, spent: BigNumber, gained: BigNumber, signature: Signature, contractAddress: string, isLightSync?: boolean): Promise<string>;
    verifyProof(eon: Eon, merkleProof: ProofOfExclusiveAllotment): Promise<any>;
    verifyProofRaw(tokenAddress: any, walletAddress: any, activeStateChecksum: any, trail: any, eonNumber: any, allotmentChain: any, membershipChain: any, values: any, left: any, right: any, passiveChecksum: any, passiveAmount: any, passiveMarker: any, contractAddress: string): Promise<any>;
    getStateUpdateEvents(tokenAddress: string, walletAddress: string, contractAddress: string): Promise<any>;
    getStateUpdateEventAtEon(tokenAddress: string, walletAddress: string, eonNumber: number, contractAddress: string): Promise<any>;
    recoverOnlyOnChainFunds(tokenAddress: string, account: string, contractAddress: string, gasPrice: BigNumber, gas: number): Promise<any>;
    getReclaimableOnChainFunds(tokenAddress: string, account: string, contractAddress: string): Promise<BigNumber>;
    recoverAllFunds(proof: ProofOfExclusiveAllotment, gasPrice: BigNumber, gas: number): Promise<any>;
    getAllReclaimableFunds(proof: ProofOfExclusiveAllotment): Promise<BigNumber>;
    private verifyProofOfTransitionAgreementLocal;
    private recoverSigningAddressLocal;
    private verifyProofOfMembershipLocal;
    private verifyProofLocal;
}
