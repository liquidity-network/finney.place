import { Withdrawal } from './../transactions/withdrawal.model';
import { ActiveState } from '../transactions/active-state.model';
import { ProofOfExclusiveAllotment } from '../primitives/proof-of-exclusive-allotment.model';
import { Deposit } from '../transactions/deposit.model';
import { MinimumAvailableBalanceMarker } from '../transactions/minimum-balance-marker.model';
import BigNumber from 'bignumber.js';
import { DeliveryProofDataInterface, SwapMatchedAmountsInterface, TransferDataInterface } from '../../interfaces/data.interface';
export declare class Eon {
    private _contractAddress;
    private _tokenAddress;
    private _walletAddress;
    private _trailIdentifier;
    private _eonNumber;
    private _activeState;
    private _proofOfExclusiveAllotment;
    proposedProofOfExclusiveAllotment: ProofOfExclusiveAllotment;
    private _withdrawals;
    private _deposits;
    private _deposited;
    private _depositedOnChain;
    private _minimumAuthorizedBalance;
    private _pendingIncomingTransfers;
    private _cancelledTransfers;
    constructor(_contractAddress: string, _tokenAddress: string, _walletAddress: string, _trailIdentifier: number, _eonNumber: number);
    static fromJSON(jsonObj: any): Eon;
    readonly json: {
        contractAddress: string;
        tokenAddress: string;
        walletAddress: string;
        trailIdentifier: number;
        eonNumber: number;
        activeState: {
            contractAddress: string;
            tokenAddress: string;
            walletAddress: string;
            trailIdentifier: number;
            eonNumber: number;
            transfers: {
                tokenAddress: string;
                address: string;
                eonNumber: number;
                amount: string;
                amountSwapped: string;
                startingBalance: string;
                recipientTokenAddress: string;
                recipient: string;
                recipientTrailIdentifier: number;
                target: string;
                nonce: string;
                txId: number;
                authorizations: any;
                confirmations: any;
                deliveryProof: DeliveryProofDataInterface;
                amountsMatched: SwapMatchedAmountsInterface;
                isPassive: boolean;
                passiveOffset: any;
                isPassiveFinalized: boolean;
            }[];
            pendingTransfer: {
                tokenAddress: string;
                address: string;
                eonNumber: number;
                amount: string;
                amountSwapped: string;
                startingBalance: string;
                recipientTokenAddress: string;
                recipient: string;
                recipientTrailIdentifier: number;
                target: string;
                nonce: string;
                txId: number;
                authorizations: any;
                confirmations: any;
                deliveryProof: DeliveryProofDataInterface;
                amountsMatched: SwapMatchedAmountsInterface;
                isPassive: boolean;
                passiveOffset: any;
                isPassiveFinalized: boolean;
            };
            spent: BigNumber;
            gained: BigNumber;
            pendingReceipt: BigNumber;
            passivelyGained: BigNumber;
        };
        proofOfExclusiveAllotment: {
            contractAddress: string;
            tokenAddress: string;
            walletAddress: string;
            activeStateChecksum: string;
            trail: number;
            eonNumber: number;
            allotmentChain: string[];
            membershipChain: string[];
            values: string[];
            left: string;
            right: string;
            passiveChecksum: string;
            passiveAmount: BigNumber;
            passiveMarker: BigNumber;
        };
        proposedProofOfExclusiveAllotment: {
            contractAddress: string;
            tokenAddress: string;
            walletAddress: string;
            activeStateChecksum: string;
            trail: number;
            eonNumber: number;
            allotmentChain: string[];
            membershipChain: string[];
            values: string[];
            left: string;
            right: string;
            passiveChecksum: string;
            passiveAmount: BigNumber;
            passiveMarker: BigNumber;
        };
        withdrawals: {
            eonNumber: number;
            amount: string;
            isReady: boolean;
        }[];
        deposits: {
            txId: string;
            block: number;
            eonNumber: number;
            amount: BigNumber;
        }[];
        deposited: BigNumber;
        depositedOnChain: BigNumber;
        minimumAuthorizedBalance: MinimumAvailableBalanceMarker;
        pendingIncomingTransfers: TransferDataInterface[];
        cancelledTransfers: TransferDataInterface[];
    };
    readonly eonNumber: number;
    readonly proofOfExclusiveAllotment: ProofOfExclusiveAllotment;
    setProofOfExclusiveAllotment(value: ProofOfExclusiveAllotment): boolean;
    readonly chainBalance: BigNumber;
    readonly proposedChainBalance: BigNumber;
    readonly activeState: ActiveState;
    readonly currentEonWithdrawalAmount: BigNumber;
    readonly isWithdrawalPending: boolean;
    readonly walletAddress: string;
    readonly trailIdentifier: number;
    readonly contractAddress: string;
    readonly tokenAddress: string;
    readonly withdrawalAmount: BigNumber;
    readonly availableBalance: BigNumber;
    readonly expectedBalance: BigNumber;
    minimumAuthorizedBalance: MinimumAvailableBalanceMarker;
    readonly availableBalanceMarker: MinimumAvailableBalanceMarker;
    setOnChainWithdrawals(withdrawals: Withdrawal[]): void;
    readonly withdrawals: Withdrawal[];
    readonly deposits: Deposit[];
    readonly offChainDeposited: BigNumber;
    addDeposit(deposit: Deposit): boolean;
    onChainDeposit: BigNumber;
    isCancelledTransfer(transferData: TransferDataInterface): boolean;
    addCancelledTransfer(transferData: TransferDataInterface): void;
    readonly cancelledTransfers: TransferDataInterface[];
    isPendingIncomingTransfer(transferData: TransferDataInterface): boolean;
    addPendingIncomingTransfer(transferData: TransferDataInterface): void;
    removePendingIncomingTransfer(transferData: TransferDataInterface): void;
    readonly pendingIncomingTransfers: TransferDataInterface[];
}
